<html>
<head>
    <title>Annotate panorama</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
          integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <style>
        div {
            margin: 5px;
        }

        select {
            vertical-align: top;
        }

        imd
    </style>
</head>

<body>
<canvas id="canvPano" height="768" width="1024"></canvas>
<br/>
<input type="button" id="buttonNone" onclick="defaultMode();" value="Select"/>
<input type="button" id="buttonPan" onclick="panningMode();" value="Pan"/>
<input type="button" id="buttonBB" onclick="bbMode();" value="Add bounding box"/>
<input type="button" id="deleteBB" onclick="deleteBB();" value="Delete Selected" disabled="True"/>
<div id="divStatus">
</div>
<div>
    <h3>Panorama Details</h3>
    <b>Description: </b><span id=panoDescription></span>
    <b>Region: </b><span id="panoRegion"></span>
    <b>Country: </b><span id="panoCountry"></span>
</div>

<div>
    <h3>Bounding boxes</h3>
    <div id="divUpdateBoundingBoxes">
        <input type="button" id="buttonUpdateAll" onclick="updateAllBoundingBoxes();"
               value="Update all bounding boxes' species to: ">
    </div>
    <div id="divBoundingBoxes"></div>
</div>
<div>
    <input type="button" value="Save" onclick="save()" id="btnSave"/>
    <input type="button" value="Cancel" onclick="cancel()" id="btnCancel"/>
</div>
<script type="text/javascript">
    // warn the user if they try to leave the page without saving
    var unsavedChanges = false;
    window.onbeforeunload = function (e) {
        if (unsavedChanges) return "Unsaved changes";
    };
    
    // parse querystring
    var urlParams;
    (window.onpopstate = function () {
        var match,
            pl = /\+/g,  // Regex for replacing addition symbol with a space
            search = /([^&=]+)=?([^&]*)/g,
            decode = function (s) {
                return decodeURIComponent(s.replace(pl, " "));
            },
            query = window.location.search.substring(1);

        urlParams = {};
        while (match = search.exec(query))
            urlParams[decode(match[1])] = decode(match[2]);
    })();


    var statusDiv = document.getElementById("divStatus");
    statusDiv.innerHTML = "checking for panorama image, please wait...";

    // Image that will be displayed on canvas
    var img = new Image();
    var panoObj;
    img.onload = function () {
        panoObj.boundingBoxes.forEach(function (bb) {
            var start = {x: bb.topLeftX, y: bb.topLeftY};
            var end = {x: bb.bottomRightX, y: bb.bottomRightY};
            addBoundingBox(start, end, bb.speciesId);
        });
        render();
        // the addboundingbox method sets unsavedChanges to true
        // we don't want it to be true yet
        unsavedChanges = false;
    };

    //ajax call to get all species
    var speciesJson;
    var xobjSpecies = new XMLHttpRequest();
    // this is a synchronous call because we want to ensure it happens before
    // any other AJAX calls that depend on this data
    xobjSpecies.open('GET', '/getAllSpecies', false); //synchronous call
    xobjSpecies.send();
    speciesJson = JSON.parse(xobjSpecies.responseText);

    // ajax call to get pano information
    var xobj = new XMLHttpRequest();
    xobj.overrideMimeType("application/json");
    xobj.onreadystatechange = function () {
        if (this.readyState == 4 && this.status == 200) {
            statusDiv.innerHTML = "";
            panoObj = JSON.parse(this.responseText);
            img.src = "pano_images/" + urlParams.panoramaId + "_z3.jpg";
            document.getElementById("panoDescription").innerHTML = panoObj.description;
            document.getElementById("panoRegion").innerHTML = panoObj.region;
            document.getElementById("panoCountry").innerHTML = panoObj.country;
            updateDisplay();
        }
    };
    xobj.open('GET', '/getPano?panoramaId=' + urlParams.panoramaId, true);
    xobj.send();


    var divSpecies = document.getElementById("divUpdateBoundingBoxes");
    var speciesDropdown = document.createElement("select");
    speciesJson.forEach(function (species) {
        var opt = document.createElement("option");
        opt.value = species.speciesId;
        opt.text = species.description;

        speciesDropdown.options.add(opt);
    });
    speciesDropdown.id = "speciesUpdateAll";
    divSpecies.appendChild(speciesDropdown);


    // global (page scope) variables
    var canvas = document.getElementById('canvPano');
    var ctx = canvas.getContext('2d');
    var bbStart = {x: 0, y: 0}; // defines bounding box start position
    var bbEnd = {x:0, y:0};  // defines bounding box end position
    var panoOffset = {x: 0, y: 0}; // panorama image offset within canvas
    var lastPanoOffset = {x: 0, y:0 };
    var mouseDownPosition = {x: 0, y:0}; // position of mouse within canvas when mouse goes down
    var currentMousePosition = {x: 0, y: 0};

    var mouseButtonDown = false;
    // canvas mouse input mode
    var modesEnum = {"Select": 0, "Pan": 1, "BoundingBox": 2};
    var mode = modesEnum.Select;

    // holds all bounding boxes
    var boundingBoxes = [];
    var nextBoundingBoxIndex = 0;

    var selectedBBIndex = -1;
    var resizingBBIndex = -1; //to store which bounding box is being resized

    var lastSpecies;

    canvas.onmousedown = function (e) { //todo: needs to be modified
        'use strict';
        // get mouse position within canvas
        // e.pageX and e.pageY are mouse coordinates within the entire window
        var xVal = e.pageX - this.offsetLeft;
        var yVal = e.pageY - this.offsetTop;
        mouseDownPosition = {x: xVal, y: yVal};

        switch (mode) {
            case modesEnum.Select:
                findBoundingBox(xVal, yVal);
                break;
            case modesEnum.Pan:

                break;

            case modesEnum.BoundingBox:
              bbStart = {x: xVal - panoOffset.x, y: yVal-panoOffset.y};
              break;
        }

        mouseButtonDown = true;
        console.debug("mouseDownPosition: ("+mouseDownPosition.x+","+mouseDownPosition.y+")");
    };
    
    canvas.onmousemove = function (e) { //todo: this method will need to be modified
        'use strict';
        // get mouse position within canvas
        // e.pageX and e.pageY are mouse coordinates within the entire window
        var xVal = e.pageX - this.offsetLeft,
            yVal = e.pageY - this.offsetTop;
        currentMousePosition = {x: xVal, y: yVal};

        if (mode == modesEnum.Pan) {
            if (mouseButtonDown) {
                panoOffset.x = lastPanoOffset.x + (currentMousePosition.x - mouseDownPosition.x);
                panoOffset.y = lastPanoOffset.y + (currentMousePosition.y - mouseDownPosition.y);

                updateDisplay();
            }
        } else if (mode == modesEnum.BoundingBox) {
            updateDisplay();
            if (mouseButtonDown) {
                bbEnd = {x: xVal - panoOffset.x, y: yVal - panoOffset.y};
                drawRectangle(bbStart, bbEnd, "#FF0000");
            } else {
                drawCrosshairs(currentMousePosition.x-panoOffset.x, 
                		currentMousePosition.y-panoOffset.y);
            }
        }
    };

    canvas.onmouseup = function (e) {  //todo: edit here for #5
        'use strict';
        mouseButtonDown = false;
        // get mouse position within canvas
        // e.pageX and e.pageY are mouse coordinates within the entire window
        var xVal = e.pageX - this.offsetLeft,
            yVal = e.pageY - this.offsetTop;
        currentMousePosition = {x: xVal, y: yVal};
        switch (mode) {
            case modesEnum.Select:
                break;
            case modesEnum.Pan:
                if( panoOffset.x > canvas.width ) {
                	panoOffset.x -= img.width;
                	//mouseDownPosition.x -= (img.width-canvas.width);
                } else if( panoOffset.x < -(img.width - canvas.width) ) {
                	panoOffset.x += img.width;
                }
                console.debug(currentMousePosition.x+","+currentMousePosition.y+" "+mouseDownPosition.x+","+mouseDownPosition.y+" "+
                		lastPanoOffset.x+","+lastPanoOffset.y);            	
        		lastPanoOffset.x = panoOffset.x;
        		lastPanoOffset.y = panoOffset.y;
                break;
            case modesEnum.BoundingBox:
              bbEnd = {x: currentMousePosition.x - panoOffset.x, 
            		y: currentMousePosition.y - panoOffset.y};
                addBoundingBox(bbStart, bbEnd, lastSpecies);
              defaultMode();
              break;
        }
    };
    function updateDisplay() {
        switch (mode) {
            case modesEnum.Select:
                canvas.style.cursor = "";
                document.getElementById("divStatus").innerHTML = "Select mode";
                break;
            case modesEnum.Pan:
                canvas.style.cursor = "move";
                document.getElementById("divStatus").innerHTML = "Panning mode";
                break;
            case modesEnum.BoundingBox:
                canvas.style.cursor = "crosshair";
                document.getElementById("divStatus").innerHTML = "Add bounding box mode";
                break;
        }

        document.getElementById("deleteBB").disabled = selectedBBIndex == -1;

        render();
    }


    function render() {

        ctx.drawImage(img, panoOffset.x, panoOffset.y);

        // wrap around image on the left
        if (panoOffset.x > 0) {
            ctx.drawImage(
                img,
                img.width - panoOffset.x, // x coordinate where to start clipping
                0, // y coordinate where to start clipping
                panoOffset.x, // width
                img.height, // height
                0, // x coordinate where to place the image
                panoOffset.y, // y coordinate where to place the image on the canvas
                panoOffset.x, // width
                img.height // height
            );
        }

        // wrap around image on the right
        if (panoOffset.x < -(img.width - canvas.width)) {
            ctx.drawImage(
                img,
                0, // x coordinate where to start clipping
                0, //y coordinate where to start clipping
                -(img.width - canvas.width + panoOffset.x), // width
                img.height, // height
                canvas.width + (img.width - canvas.width + panoOffset.x), // x coordinate where to place the image
                panoOffset.y, // y coordinate where to place the image
                -(img.width - canvas.width + panoOffset.x), // width
                img.height // height
            );
        }

        drawBoundingBoxes();
    }

    function drawCrosshairs(x, y) {
        ctx.strokeStyle = "#FF0000"
        ctx.beginPath();
        ctx.moveTo(0, panoOffset.y + y);
        ctx.lineTo(img.width, panoOffset.y + y);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(panoOffset.x + x, 0);
        ctx.lineTo(panoOffset.x + x, img.height);
        ctx.stroke();
    }

    function drawRectangle(start, end, style, width) {
        ctx.strokeStyle = style;
        ctx.lineWidth = width;
        ctx.strokeRect(start.x + panoOffset.x, start.y + panoOffset.y,
            end.x - start.x, end.y - start.y);
    }

    function drawBoundingBoxes() {
        for (var i = 0; i < boundingBoxes.length; ++i) {
            var style = "#00FF00";
            var width = 1;
            if (selectedBBIndex == i) {
                style = "#FF0000";
                width = 5;
            }
            drawRectangle(boundingBoxes[i].start, boundingBoxes[i].end, style, width);
        }
    }

    function findBoundingBox(x, y) { //todo: this method will be useful
        x -= panoOffset.x;
        y -= panoOffset.y;
        selectedBBIndex = -1;
        for (var i = 0; i < boundingBoxes.length; ++i) {
            var bb = boundingBoxes[i];
            if (x >= bb.start.x && x <= bb.end.x && y >= bb.start.y && y <= bb.end.y) {
                selectedBBIndex = i;
                break;
            }
        }

        updateDisplay();

    }

    function updateAllBoundingBoxes() {
        var newSpeciesValue = document.getElementById("speciesUpdateAll").value;

        boundingBoxes.forEach(function (bb, index) {
            document.getElementById("bbSpecies" + bb.index).value = newSpeciesValue;
        });

        lastSpecies = newSpeciesValue;
    }

    function addBoundingBox(bbStart, bbEnd, speciesId) {
        var bbid = nextBoundingBoxIndex;
        nextBoundingBoxIndex++;
        // in case bounding box was not drawn from top left to bottom right
        var startX = Math.min(bbStart.x, bbEnd.x);
        var endX = Math.max(bbStart.x, bbEnd.x);
        var startY = Math.min(bbStart.y, bbEnd.y);
        var endY = Math.max(bbStart.y, bbEnd.y);

        var newbb = {index: bbid, start: {x: startX, y: startY}, end: {x: endX, y: endY}};

        // add bounding box to page
        var bbdiv = document.getElementById("divBoundingBoxes");

        var newdiv = document.createElement("div");
        newdiv.id = "divBB" + bbid;

        // display bounding box image
        var newimg = document.createElement("canvas");
        newimg.width = endX - startX;
        newimg.height = endY - startY;
        var newctx = newimg.getContext('2d');
        newctx.drawImage(img,
            startX, // where to start clipping
            startY, // where to start clipping
            endX - startX, // width
            endY - startY, // height
            0, // where to place image on canvas
            0, // where to place image on canvas
            endX - startX, // width
            endY - startY); // height
        newdiv.appendChild(newimg);

        var speciesDropdown = document.createElement("select");
        speciesDropdown.onchange = function (e) {
            lastSpecies = e.currentTarget.value;
            unsavedChanges = true;
        };
        speciesJson.forEach(function (species) {
            var opt = document.createElement("option");
            opt.value = species.speciesId;
            opt.text = species.description;
            if (opt.value == speciesId) {
                opt.selected = true;
            }
            speciesDropdown.options.add(opt);
        });
        speciesDropdown.id = "bbSpecies" + bbid;
        newdiv.appendChild(speciesDropdown);

        bbdiv.appendChild(newdiv);
        boundingBoxes.push(newbb);

        lastSpecies = speciesId;

        unsavedChanges = true;
    }

    function updateBoundingBox(bbNewStart, bbNewEnd, speciesId, bbid) { //todo: call this to update bounding box
        //in case bounding box was not drawn from top left to bottom right
        var startX = Math.min(bbNewStart.x, bbNewEnd.x);
        var endX = Math.max(bbNewStart.x, bbNewEnd.x);
        var startY = Math.min(bbNewStart.y, bbNewEnd.y);
        var endY = Math.max(bbNewStart.y, bbNewEnd.y);

        var updatedBB = {index: bbid, start: {x: startX, y: startY}, end: {x: endX, y: endY}};

        var updateDiv = document.getElementById("divBB" + bbid);

        updateDiv.innerHTML = "";

        // display bounding box image
        var newimg = document.createElement("canvas");
        newimg.id = "bbImage" + bbid;
        newimg.width = endX - startX;
        newimg.height = endY - startY;
        var newctx = newimg.getContext('2d');
        newctx.drawImage(img,
            startX, // where to start clipping
            startY, // where to start clipping
            endX - startX, // width
            endY - startY, // height
            0, // where to place image on canvas
            0, // where to place image on canvas
            endX - startX, // width
            endY - startY); // height
        updateDiv.appendChild(newimg);

        var speciesDropdown = document.createElement("select");
        speciesDropdown.onchange = function (e) {
            unsavedChanges = true;
        };
        speciesJson.forEach(function (species) {
            var opt = document.createElement("option");
            opt.value = species.speciesId;
            opt.text = species.description;
            if (opt.value == speciesId) {
                opt.selected = true;
            }
            speciesDropdown.options.add(opt);
        });
        speciesDropdown.id = "bbSpecies" + boundingBoxes.length;
        updateDiv.appendChild(speciesDropdown);


    }

    function save() {
        var saveButton = document.getElementById("btnSave");
        saveButton.disabled = true;
        saveButton.value = "Saving...";
        // put in format back end will understand
        var pano = {panoramaId: urlParams.panoramaId, lat: 0, lng: 0, image: "", boundingBoxes: []};
        boundingBoxes.forEach(function (bb, index) {
            var newbb = {
                topLeftX: bb.start.x, topLeftY: bb.start.y,
                bottomRightX: bb.end.x, bottomRightY: bb.end.y
            };
            newbb.speciesId = document.getElementById("bbSpecies" + bb.index).value;
            pano.boundingBoxes.push(newbb);
        });

        json = JSON.stringify(pano);
        var xobj = new XMLHttpRequest();
        xobj.open('POST', '/savePano');
        xobj.setRequestHeader("Content-Type", "application/json");
        xobj.onreadystatechange = function () {
            if (this.readyState == 4 && this.status == 200) {
                saveButton.value = "Done";
                unsavedChanges = false;
                window.location.assign("/panoramas.html");
            }
        };
        xobj.send(json);
    }

    function cancel() {
        unsavedChanges = false;
        window.location.assign("/panoramas.html");
    }
    
    function deleteBB() {
        if (selectedBBIndex != -1) {
            boundingBoxes.splice(selectedBBIndex, 1);
        }
        document.getElementById("divBoundingBoxes")
            .removeChild(document.getElementById("divBB" + selectedBBIndex));

        selectedBBIndex = -1;
        updateDisplay();
    }

    function defaultMode() {
        mode = modesEnum.Select;
        updateDisplay();
    }

    function panningMode() {
        mode = modesEnum.Pan;
        updateDisplay();
    }

    function bbMode() {
        mode = modesEnum.BoundingBox;
        updateDisplay();
    }
    
</script>
</body>
</html>
